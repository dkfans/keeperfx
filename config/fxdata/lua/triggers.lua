
---@alias event_type "PowerCast"|"Death"|"SpecialActivated"|"GameTick"|"ChatMsg"

---@class Trigger
---@field conditions TriggerCondition[]|nil
---@field action function|string
---@field event event_type
---@field index integer
---@field triggerData table

---@class TriggerCondition
---@field condition function
---@field enabled boolean

require "debug"

--- @param func function|string
local function validatefunc(func)
    if type(func) == "function" then
        if debug.getupvalue(func, 1) ~= nil then
            local n, v = debug.getupvalue(func, 1)
            error("upvalue " .. n .. " found, functions may not contain upvalues, avoid accessing vars local to the file, alternatively pass function name as a string")
        end

    elseif type(func) == "string" then
        if _G[func] == nil then
            error("function '" .. func .."' not found, make sure it is defined globally")
        end
    else
        error("param not a function but " .. type(func))
    end

end

--- Creates a new trigger and returns it
---@param event event_type
---@param action function|string
---@param triggerData? table
---@return table
function CreateTrigger(event,action,triggerData)
    validatefunc(action)
    Game.triggers = Game.triggers or {}
    local trigger = { index = #Game.triggers + 1, event = event, conditions = {}, action = action, triggerData = triggerData }
    table.insert(Game.triggers, trigger)
    return trigger
end

--- Adds a condition function that needs to evaluate to true for the actions to be triggered when the event happens
--- @param trigger Trigger
--- @param condition function|string Function that returns true or false
--- @return TriggerCondition condition
function TriggerAddCondition(trigger, condition)
    validatefunc(condition)
    local triggerCondition = { condition = condition, enabled = true }
    trigger.conditions = trigger.conditions or {}
    table.insert(trigger.conditions, triggerCondition)
    return triggerCondition
end

--- Processes a trigger
--- @param trigger Trigger The trigger to process
--- @param eventData table The data generated by the event
local function ProcessTrigger(trigger,eventData)
    local allConditionsMet = true
    if trigger.conditions then
        for _, condition in ipairs(trigger.conditions) do
            if (type(condition.condition) == "function" and condition.condition(eventData,trigger.triggerData) == false) or
               (type(condition.condition) == "string" and _G[condition.condition](eventData,trigger.triggerData) == false) then
                allConditionsMet = false
                break
            end
        end
    end
    if allConditionsMet then
        if type(trigger.action) == "function" then
            trigger.action(eventData,trigger.triggerData)
        else
            _G[trigger.action](eventData,trigger.triggerData)
        end
    end
end

--- goes trough all triggers and checks if they have an event that matches the eventType
--- @param eventType event_type
local function ProcessEvent(eventType,eventData)
    Game.triggers = Game.triggers or {}
    for _, trigger in ipairs(Game.triggers) do
        if trigger.event == eventType then
            ProcessTrigger(trigger,eventData)
        end
    end
end



--- Called when a spell is cast on a unit
--- @param pwkind power_kind
--- @param caster Player
--- @param target_thing Creature
--- @param stl_x integer
--- @param stl_y integer
--- @param splevel integer
function OnPowerCast(pwkind, caster, target_thing, stl_x, stl_y, splevel)
    local eventData = {}
    eventData.Thing = target_thing
    eventData.PowerKind = pwkind
    eventData.Player = caster
    eventData.stl_x = stl_x
    eventData.stl_y = stl_y
    eventData.splevel = splevel
    ProcessEvent("PowerCast",eventData)
end

--- Called when a unit dies
--- @param unit Creature The unit that dies
function OnUnitDeath(unit)
    local eventData = {}
    eventData.Thing = unit
    ProcessEvent("Death",eventData)
end

--- Called on each game tick to process timer events
function OnGameTick()
    local eventData = {}
    eventData.CurrentTurn = PLAYER0.GAME_TURN
    ProcessEvent("GameTick",eventData)
end

--- Called when a special box is activated
--- @param player Player
--- @param crate_thing Thing
function OnSpecialActivated(player,crate_thing)
    local eventData = {}
    eventData.Thing = crate_thing
    eventData.Player = player
    ProcessEvent("SpecialActivated",eventData)
end

--- @param player Player
--- @param message string
function OnChatMsg(player,message)
    local eventData = {}
    eventData.Player = player
    eventData.Message = message
    ProcessEvent("ChatMsg",eventData)
end













---
---@param action function|string the function to call when the event happens
---@param SpecialBoxId? integer
---@return Trigger
function RegisterSpecialActivatedEvent(action,SpecialBoxId)
    local trigData = {SpecialBoxId = SpecialBoxId}
    local trigger = CreateTrigger("SpecialActivated",action,trigData)
    if SpecialBoxId then
        TriggerAddCondition(trigger, function(eventData,triggerData) return eventData.SpecialBoxId == triggerData.SpecialBoxId end)
    end
    return trigger
end

---
---@param action function|string the function to call when the event happens
---@param time integer amount of gameticks (1/20 s)
---@param periodic boolean whether the trigger should activate once, or repeat every 'time' gameticks
---@return Trigger
function RegisterTimerEvent(action, time, periodic)
    local trigData = {creationTurn = PLAYER0.GAME_TURN, time = time}
    local trigger = CreateTrigger("GameTick",action,trigData)
    if periodic then
        TriggerAddCondition(trigger, function(eventData,triggerData) return ((eventData.CurrentTurn ~= triggerData.creationTurn) and (eventData.CurrentTurn - triggerData.creationTurn) % triggerData.time == 0) end)
    else
        TriggerAddCondition(trigger, function(eventData,triggerData) return (eventData.CurrentTurn == (triggerData.creationTurn + triggerData.time)) end)
    end

    return trigger
end

---@param action function|string the function to call when the event happens
---@param condition function|string the condition that needs to be true for the action to be triggered
---@return Trigger
function RegisterOnConditionEvent(action, condition)
    local trigger = CreateTrigger("GameTick",action)
    TriggerAddCondition(trigger, condition)
    return trigger
end

---@param action function|string the function to call when the event happens
---@param powerKind? power_kind the spell type that triggers the event
---@return Trigger
function RegisterPowerCastEvent(action,powerKind)
    print("RegisterPowerCastEvent",powerKind)
    local trigData = {PowerKind = powerKind}
    local trigger = CreateTrigger("PowerCast",action,trigData)
    if powerKind then
        TriggerAddCondition(trigger, function(eventData,triggerData) return eventData.PowerKind == triggerData.PowerKind end)
    end
    return trigger
end


--function Thing:RegisterSpecialActivatedEvent(action) 
--    local trigger = CreateTrigger()
--    TriggerRegisterThingEvent(trigger, nil, "SpecialActivated")
--    TriggerAddCondition(trigger, function() return self == GetTriggeringThing() end)
--    TriggerAddAction(trigger, action)
--end

--TimerEvents
--  periodic or not
--PlayerEvents
--  "Win"|"Lose"|"AlliesChange"
--SlabEvent
--  "OwnerChange"|"TypeChange"

--ThingEvents
--  "powerCast"|"dies"|"SpecialActivated" --|"healthChange"|"happinessChange"|"stateChange"
--TrapEvents
--  "Placed"|"triggered"|"depleted"